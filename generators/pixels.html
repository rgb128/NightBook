<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Letter Generator (from Image Trace)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: #eee;
        }
        h1, h3 { text-align: center; }
        #controls {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 5px;
            background: #2a2a2a;
        }
        #outputs {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        #outputs svg {
            border: 1px solid #444;
            background-color: #fff; /* Keep SVG background white for clarity */
        }
        #outputs canvas {
            border: 1px solid #444;
        }
        #debugCanvases {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        #debugCanvases canvas {
            border: 1px dotted gray;
        }
        #debugCanvases p {
            text-align: center;
            margin: 0;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <h1>Neon Letter Generator (from Image Trace)</h1>
    <div id="controls">
        <div>
            <label for="letterInput">Letter:</label>
            <input type="text" id="letterInput" value="a" maxlength="1">
        </div>
        <div>
            <label for="fontInput">Font:</label>
            <input type="text" id="fontInput" value="bold 128px sans-serif">
        </div>
        <div>
            <label for="smoothingInput">Smoothing:</label>
            <input type="number" id="smoothingInput" value="1.5" step="0.1">
        </div>
        <button onclick="run()">Generate Outline</button>
    </div>
    
    <div id="outputs">
        <div>
            <h3>Generated SVG Outline:</h3>
            <div id="svgContainer"></div>
        </div>
        <div>
            <h3>Neon Effect:</h3>
            <div id="neonCanvasContainer"></div>
        </div>
    </div>
    
    <h3>For Debugging - The Canvases:</h3>
    <div id="debugCanvases">
        <div id="originalCanvasContainer"><p>Original</p></div>
        <div id="holeCanvasContainer"><p>Holes Only</p></div>
    </div>


<script>
    // ALGORITHM CONSTANTS
    const CANVAS_WIDTH = 200;
    const CANVAS_HEIGHT = 200;
    const ALPHA_THRESHOLD = 128;
    let SMOOTHING_TOLERANCE = 1.5; 

    /**
     * Main function to generate the SVG path string for a given letter and font.
     */
    function generateLetterOutline(letter, font) {
        const originalCtx = getContextWithLetter(letter, font);
        const originalMatrix = getPixelMatrix(originalCtx);
        document.getElementById('originalCanvasContainer').appendChild(originalCtx.canvas);

        const startPoint = findStartPoint(originalMatrix);
        if (!startPoint) {
            console.log("No letter pixels found.");
            return "";
        }
        
        const outerPath = simplifyPath(traceBoundary(originalMatrix, startPoint));

        const filledMaskMatrix = createFilledMask(outerPath);
        const holeMatrix = new Array(CANVAS_HEIGHT).fill(0).map(() => new Array(CANVAS_WIDTH).fill(0));
        for (let y = 0; y < CANVAS_HEIGHT; y++) {
            for (let x = 0; x < CANVAS_WIDTH; x++) {
                if (filledMaskMatrix[y][x] === 1 && originalMatrix[y][x] === 0) {
                    holeMatrix[y][x] = 1;
                }
            }
        }
        
        const holeCtx = document.createElement('canvas').getContext('2d');
        holeCtx.canvas.width = CANVAS_WIDTH;
        holeCtx.canvas.height = CANVAS_HEIGHT;
        drawMatrixToCanvas(holeMatrix, holeCtx);
        document.getElementById('holeCanvasContainer').innerHTML = '<p>Holes Only</p>';
        document.getElementById('holeCanvasContainer').appendChild(holeCtx.canvas);

        const allPaths = [outerPath];
        let holeStartPoint;
        while (holeStartPoint = findStartPoint(holeMatrix)) {
            const innerPath = simplifyPath(traceBoundary(holeMatrix, holeStartPoint));
            allPaths.push(innerPath);
            floodFill(holeMatrix, holeStartPoint, 0);
        }

        return convertPathsToSVGString(allPaths);
    }

    // ==================================================================================
    // PATH SIMPLIFICATION AND SMOOTHING
    // ==================================================================================
    function simplifyPath(path) {
        const collinearRemoved = removeCollinearPoints(path);
        return ramerDouglasPeucker(collinearRemoved, SMOOTHING_TOLERANCE);
    }
    function removeCollinearPoints(path) {
        if (path.length < 3) return path;
        const newPath = [path[0]];
        for (let i = 1; i < path.length - 1; i++) {
            const p1 = newPath[newPath.length - 1];
            const p2 = path[i];
            const p3 = path[i+1];
            const crossProduct = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
            if (crossProduct !== 0) {
                newPath.push(p2);
            }
        }
        newPath.push(path[path.length - 1]);
        return newPath;
    }
    function ramerDouglasPeucker(points, epsilon) {
        if (points.length < 3) return points;
        let dmax = 0;
        let index = 0;
        const end = points.length - 1;
        for (let i = 1; i < end; i++) {
            const d = perpendicularDistance(points[i], points[0], points[end]);
            if (d > dmax) {
                index = i;
                dmax = d;
            }
        }
        if (dmax > epsilon) {
            const recResults1 = ramerDouglasPeucker(points.slice(0, index + 1), epsilon);
            const recResults2 = ramerDouglasPeucker(points.slice(index, points.length), epsilon);
            return recResults1.slice(0, recResults1.length - 1).concat(recResults2);
        } else {
            return [points[0], points[end]];
        }
    }
    function perpendicularDistance(point, lineStart, lineEnd) {
        let dx = lineEnd.x - lineStart.x;
        let dy = lineEnd.y - lineStart.y;
        if (dx === 0 && dy === 0) {
            dx = point.x - lineStart.x;
            dy = point.y - lineStart.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (dx * dx + dy * dy);
        const closestPoint = { x: lineStart.x + t * dx, y: lineStart.y + t * dy };
        dx = point.x - closestPoint.x;
        dy = point.y - closestPoint.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // ==================================================================================
    // CORE HELPER FUNCTIONS
    // ==================================================================================
    function getContextWithLetter(letter, font) {
        const canvas = document.createElement('canvas');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.font = font;
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(letter, canvas.width / 2, canvas.height / 2);
        return ctx;
    }
    function getPixelMatrix(ctx) {
        const imageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        const matrix = [];
        for (let y = 0; y < CANVAS_HEIGHT; y++) {
            matrix[y] = [];
            for (let x = 0; x < CANVAS_WIDTH; x++) {
                const alpha = imageData.data[(y * CANVAS_WIDTH + x) * 4 + 3];
                matrix[y][x] = alpha > ALPHA_THRESHOLD ? 1 : 0;
            }
        }
        return matrix;
    }
    function createFilledMask(path) {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.canvas.width = CANVAS_WIDTH;
        ctx.canvas.height = CANVAS_HEIGHT;
        ctx.beginPath();
        if (path.length > 0) {
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
        }
        ctx.closePath();
        ctx.fill();
        return getPixelMatrix(ctx);
    }
    function findStartPoint(matrix) {
        for (let y = 0; y < matrix.length; y++) {
            for (let x = 0; x < matrix[y].length; x++) {
                if (matrix[y][x] === 1) return { x, y };
            }
        }
        return null;
    }
    function traceBoundary(matrix, startPoint) {
        const path = [];
        let currentPoint = { ...startPoint };
        const neighbors = [
            { dx: -1, dy: 0 }, { dx: -1, dy: -1 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 },
            { dx: 1, dy: 0 }, { dx: 1, dy: 1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 1 }
        ];
        let dir = 4;
        do {
            path.push({ x: currentPoint.x, y: currentPoint.y });
            let foundNext = false;
            for (let i = 0; i < 8; i++) {
                const checkDir = (dir + i) % 8;
                const nextPoint = { x: currentPoint.x + neighbors[checkDir].dx, y: currentPoint.y + neighbors[checkDir].dy };
                if (nextPoint.x >= 0 && nextPoint.x < CANVAS_WIDTH && nextPoint.y >= 0 && nextPoint.y < CANVAS_HEIGHT && matrix[nextPoint.y][nextPoint.x] === 1) {
                    currentPoint = nextPoint;
                    dir = (checkDir + 5) % 8;
                    foundNext = true;
                    break;
                }
            }
            if (!foundNext) break;
        } while (currentPoint.x !== startPoint.x || currentPoint.y !== startPoint.y);
        return path;
    }
    function floodFill(matrix, startPoint, fillValue) {
        const originalValue = matrix[startPoint.y][startPoint.x];
        if (originalValue === fillValue) return;
        const stack = [startPoint];
        while (stack.length > 0) {
            const { x, y } = stack.pop();
            if (x < 0 || x >= CANVAS_WIDTH || y < 0 || y >= CANVAS_HEIGHT || matrix[y][x] !== originalValue) continue;
            matrix[y][x] = fillValue;
            stack.push({ x: x + 1, y: y }); stack.push({ x: x - 1, y: y });
            stack.push({ x: x, y: y + 1 }); stack.push({ x: x, y: y - 1 });
        }
    }
    function calculateSignedArea(path) {
        let area = 0;
        for (let i = 0; i < path.length; i++) {
            area += (path[i].x * path[(i + 1) % path.length].y) - (path[(i + 1) % path.length].x * path[i].y);
        }
        return area / 2;
    }
    function convertPathsToSVGString(paths) {
        if (paths.length === 0 || paths[0].length === 0) return "";
        const sortedPaths = paths.sort((a, b) => Math.abs(calculateSignedArea(b)) - Math.abs(calculateSignedArea(a)));
        let svgString = "";
        for (let i = 0; i < sortedPaths.length; i++) {
            let path = sortedPaths[i];
            const area = calculateSignedArea(path);
            if (i === 0 && area < 0) path.reverse();
            else if (i > 0 && area > 0) path.reverse();
            svgString += "M" + path.map(p => `${p.x} ${p.y}`).join(" L") + " Z ";
        }
        return svgString.trim();
    }
    function drawMatrixToCanvas(matrix, ctx) {
        const imageData = ctx.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT);
        for (let y = 0; y < CANVAS_HEIGHT; y++) {
            for (let x = 0; x < CANVAS_WIDTH; x++) {
                const index = (y * CANVAS_WIDTH + x) * 4;
                const value = matrix[y][x] === 1 ? 0 : 255;
                imageData.data.set([value, value, value, 255], index);
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }
    
    // ==================================================================================
    // NEON EFFECT RENDERING (NEW)
    // ==================================================================================
    /**
     * Renders a neon glow effect on a canvas from an SVG path string.
     * @param {string} svgPathData The 'd' attribute string from an SVG path.
     */
    function drawNeonEffect(svgPathData) {
        const container = document.getElementById('neonCanvasContainer');
        container.innerHTML = ''; // Clear previous canvas
        const canvas = document.createElement('canvas');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        const path2d = new Path2D(svgPathData);
        
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const neonColor = '#00ffff'; // Cyan

        // Layer 1: Wide, diffuse outer glow
        ctx.strokeStyle = neonColor;
        ctx.lineWidth = 7;
        ctx.globalAlpha = 0.2;
        ctx.shadowBlur = 15;
        ctx.shadowColor = neonColor;
        ctx.stroke(path2d);

        // Layer 2: Medium main glow
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.4;
        ctx.shadowBlur = 10;
        ctx.stroke(path2d);

        // Layer 3: Sharp inner color
        ctx.lineWidth = 2;
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 5;
        ctx.stroke(path2d);
        
        // Layer 4: Bright white core
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.shadowBlur = 0;
        ctx.stroke(path2d);
    }

    // ==================================================================================
    // UI AND DEMONSTRATION
    // ==================================================================================
    function run() {
        document.getElementById('originalCanvasContainer').innerHTML = '<p>Original</p>';
        document.getElementById('holeCanvasContainer').innerHTML = '<p>Holes Only</p>';
        
        const letter = document.getElementById('letterInput').value;
        const font = document.getElementById('fontInput').value;
        SMOOTHING_TOLERANCE = parseFloat(document.getElementById('smoothingInput').value);
        
        if (!letter) {
            alert("Please enter a letter.");
            return;
        }

        const pathData = generateLetterOutline(letter[0], font);
        
        console.log("Generated SVG Path:", pathData);
        
        if (pathData) {
            const svgHtml = `
                <svg width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" viewBox="0 0 ${CANVAS_WIDTH} ${CANVAS_HEIGHT}">
                    <path d="${pathData}" fill="none" stroke="blue" stroke-width="1"/>
                </svg>
            `;
            document.getElementById('svgContainer').innerHTML = svgHtml;

            // Render the neon effect
            drawNeonEffect(pathData);

        } else {
            document.getElementById('svgContainer').innerHTML = "<p>Could not generate outline.</p>";
            document.getElementById('neonCanvasContainer').innerHTML = ''; // Clear neon canvas too
        }
    }
    
    window.onload = run;
</script>

</body>
</html>
